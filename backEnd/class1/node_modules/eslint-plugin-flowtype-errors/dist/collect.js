'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlowSeverity = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.collect = collect;
exports.coverage = coverage;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _slash = require('slash');

var _slash2 = _interopRequireDefault(_slash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var flowBin = void 0;
/**
 * Run Flow and collect errors in JSON format
 *
 * Reference the following links for possible bug fixes and optimizations
 * https://github.com/facebook/nuclide/blob/master/pkg/nuclide-flow-rpc/lib/FlowRoot.js
 * https://github.com/ptmt/tryflow/blob/gh-pages/js/worker.js
 */


try {
  if (!process.env.FLOW_BIN) {
    flowBin = require('flow-bin'); // eslint-disable-line global-require
  }
} catch (e) {
  /* eslint-disable */
  console.log();
  console.log('Oops! Something went wrong! :(');
  console.log();
  console.log('eslint-plugin-flowtype-errors could not find the package "flow-bin". This can happen for a couple different reasons.');
  console.log();
  console.log('1. If ESLint is installed globally, then make sure "flow-bin" is also installed globally.');
  console.log();
  console.log('2. If ESLint is installed locally, then it\'s likely that "flow-bin" is not installed correctly. Try reinstalling by running the following:');
  console.log();
  console.log('  npm i -D flow-bin@latest');
  console.log();
  process.exit(1);
  /* eslint-enable */
}

var FlowSeverity = exports.FlowSeverity = {
  Error: 'error',
  Warning: 'warning'
};

function fatalError(message) {
  return [{
    level: FlowSeverity.Error,
    loc: { start: { line: 1, column: 1 }, end: { line: 1, column: 1 } },
    message
  }];
}

function formatSeePath(loc, root, flowVersion) {
  if (loc.source === null) {
    return '??';
  }

  return loc.type === 'LibFile' ? `https://github.com/facebook/flow/blob/v${flowVersion}/lib/${_path2.default.basename(loc.source)}#L${loc.start.line}` : `.${(0, _slash2.default)(loc.source.replace(root, ''))}:${loc.start.line}`;
}

function formatSimpleMessage(message) {
  return message.kind === 'Code' ? `\`${message.text}\`` : message.text;
}

function formatReferenceMessage(message, errorData) {
  var errorLoc = errorData.errorLoc,
      referenceLocs = errorData.referenceLocs,
      root = errorData.root,
      flowVersion = errorData.flowVersion,
      lineOffset = errorData.lineOffset;

  var referenceLoc = referenceLocs[message.referenceId];
  var messageStr = message.message.map(formatSimpleMessage).join('');

  if (referenceLoc.source !== errorLoc.source) {
    messageStr += ` (see ${formatSeePath(referenceLoc, root, flowVersion)})`;
  } else if (referenceLoc.start.line !== errorLoc.start.line) {
    messageStr += ` (see line ${referenceLoc.start.line + lineOffset})`;
  }

  return messageStr;
}

function formatInlineMessage(message, errorData) {
  return message.kind === 'Reference' ? formatReferenceMessage(message, errorData) : formatSimpleMessage(message);
}

function formatInlineMessageArray(messages, errorData) {
  return messages.map(function (message) {
    return formatInlineMessage(message, errorData);
  }).join('');
}

function formatMessage(message, errorData) {
  if (Array.isArray(message)) {
    return formatInlineMessageArray(message, errorData);
  }

  return [formatInlineMessageArray(message.message, errorData)].concat((0, _toConsumableArray3.default)(message.items.map(function (itemMessage) {
    return formatMessage(itemMessage, errorData);
  }))).join(' ');
}

function getFlowBin() {
  return process.env.FLOW_BIN || flowBin;
}

var didExecute = false;

function onExit(root) {
  if (!didExecute) {
    didExecute = true;
    process.on('exit', function () {
      return _child_process2.default.spawnSync(getFlowBin(), ['stop', root]);
    });
  }
}

function spawnFlow(mode, input, root, stopOnExit, filepath) {
  var extraOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];

  if (!input) {
    return true;
  }

  var child = _child_process2.default.spawnSync(getFlowBin(), [mode, '--json', `--root=${root}`, filepath].concat((0, _toConsumableArray3.default)(extraOptions)), {
    input,
    encoding: 'utf-8'
  });

  var stdout = child.stdout;

  if (!stdout) {
    // Flow does not support 32 bit OS's at the moment.
    return false;
  }

  if (stopOnExit) {
    onExit(root);
  }

  return stdout.toString();
}

function determineRuleType(description) {
  return description.toLowerCase().includes('missing type annotation') ? 'missing-annotation' : 'default';
}

function collect(stdin, root, stopOnExit, filepath, programOffset) {
  var stdout = spawnFlow('check-contents', stdin, root, stopOnExit, filepath, ['--json-version=2']);

  if (typeof stdout !== 'string') {
    return stdout;
  }

  var json = void 0;

  try {
    json = JSON.parse(stdout);
  } catch (e) {
    return fatalError('Flow returned invalid json');
  }

  if (!Array.isArray(json.errors)) {
    return json.exit ? fatalError(`Flow returned an error: ${json.exit.msg} (code: ${json.exit.code})`) : fatalError('Flow returned invalid json');
  }

  var output = json.errors.map(function (error) {
    var loc = error.primaryLoc;

    var message = formatMessage(error.messageMarkup, {
      errorLoc: loc,
      referenceLocs: error.referenceLocs,
      root,
      flowVersion: json.flowVersion,
      lineOffset: programOffset.line
    });

    var newLoc = {
      start: {
        line: loc.start.line + programOffset.line,
        column: loc.start.line === 0 ? loc.start.column + programOffset.column : loc.start.column,
        offset: loc.start.offset
      },
      end: {
        line: loc.end.line + programOffset.line,
        column: loc.end.line === 0 ? loc.end.column + programOffset.column : loc.end.column,
        offset: loc.end.offset
      }
    };

    return (0, _extends3.default)({}, process.env.DEBUG_FLOWTYPE_ERRRORS === 'true' ? json : {}, {
      type: determineRuleType(message),
      level: error.level || FlowSeverity.Error,
      message,
      path: loc.source,
      start: newLoc.start.line,
      end: newLoc.end.line,
      loc: newLoc
    });
  });

  return output;
}

function coverage(stdin, root, stopOnExit, filepath) {
  var stdout = spawnFlow('coverage', stdin, root, stopOnExit, filepath);

  if (typeof stdout !== 'string') {
    return stdout;
  }

  var expressions = void 0;

  try {
    expressions = JSON.parse(stdout).expressions;
  } catch (e) {
    return {
      coveredCount: 0,
      uncoveredCount: 0
    };
  }

  return {
    coveredCount: expressions.covered_count,
    uncoveredCount: expressions.uncovered_count
  };
}