'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _collect = require('./collect');

var _getProgram = require('./get-program');

var _getProgram2 = _interopRequireDefault(_getProgram);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var runOnAllFiles = void 0;

function hasFlowPragma(source) {
  return source.getAllComments().some(function (comment) {
    return (/@flow/.test(comment.value)
    );
  });
}

function lookupFlowDir(context) {
  var root = process.cwd();
  var flowDirSetting = context.settings && context.settings['flowtype-errors'] && context.settings['flowtype-errors'].flowDir || '.';

  return _fs2.default.existsSync(_path2.default.join(root, flowDirSetting, '.flowconfig')) ? _path2.default.join(root, flowDirSetting) : root;
}

function stopOnExit(context) {
  return !!(context.settings && context.settings['flowtype-errors'] && context.settings['flowtype-errors'].stopOnExit);
}

function errorFlowCouldNotRun(loc) {
  return {
    loc,
    message: `Flow could not be run. Possible causes include:
  * Running on 32-bit OS (https://github.com/facebook/flow/issues/2262)
  * Recent glibc version not available (https://github.com/flowtype/flow-bin/issues/49)
  * FLOW_BIN environment variable ${process.env.FLOW_BIN ? 'set incorrectly' : 'not set'}
.`
  };
}

function createFilteredErrorRule(filter) {
  return function showErrors(context) {
    return {
      Program(node) {
        var source = context.getSourceCode();
        var flowDir = lookupFlowDir(context);

        // Check to see if we should run on every file
        if (runOnAllFiles === undefined) {
          try {
            runOnAllFiles = _fs2.default.readFileSync(_path2.default.join(flowDir, '.flowconfig')).toString().includes('all=true');
          } catch (err) {
            runOnAllFiles = false;
          }
        }

        if (runOnAllFiles === false && !hasFlowPragma(source)) {
          return;
        }

        var program = (0, _getProgram2.default)(source, node);
        if (!program) {
          return;
        }

        var collected = (0, _collect.collect)(program.text, flowDir, stopOnExit(context), context.getFilename(), program.offset);

        if (collected === true) {
          return;
        }

        if (collected === false) {
          context.report(errorFlowCouldNotRun(program.loc));
          return;
        }

        collected.filter(filter).forEach(function (_ref) {
          var loc = _ref.loc,
              message = _ref.message;

          context.report({
            loc: loc ? (0, _extends3.default)({}, loc, {
              start: (0, _extends3.default)({}, loc.start, {
                // Flow's column numbers are 1-based, while ESLint's are 0-based.
                column: loc.start.column - 1
              })
            }) : loc,
            message
          });
        });
      }
    };
  };
}

exports.default = {
  rules: {
    'enforce-min-coverage': function enforceMinCoverage(context) {
      return {
        Program(node) {
          var source = context.getSourceCode();

          if (hasFlowPragma(source)) {
            var program = (0, _getProgram2.default)(source, node);
            if (!program) {
              return;
            }

            var res = (0, _collect.coverage)(program.text, lookupFlowDir(context), stopOnExit(context), context.getFilename());

            if (res === true) {
              return;
            }

            if (res === false) {
              context.report(errorFlowCouldNotRun(program.loc));
              return;
            }

            var requiredCoverage = context.options[0];
            var coveredCount = res.coveredCount,
                uncoveredCount = res.uncoveredCount;

            /* eslint prefer-template: 0 */

            var percentage = Number(Math.round(coveredCount / (coveredCount + uncoveredCount) * 10000) + 'e-2');

            if (percentage < requiredCoverage) {
              context.report({
                loc: program.loc,
                message: `Expected coverage to be at least ${requiredCoverage}%, but is: ${percentage}%`
              });
            }
          }
        }
      };
    },
    'show-errors': createFilteredErrorRule(function (_ref2) {
      var level = _ref2.level;
      return level !== _collect.FlowSeverity.Warning;
    }),
    'show-warnings': createFilteredErrorRule(function (_ref3) {
      var level = _ref3.level;
      return level === _collect.FlowSeverity.Warning;
    })
  }
};
module.exports = exports['default'];